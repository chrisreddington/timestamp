# Sync Theme Metadata Workflow
#
# PURPOSE: Keeps theme-related files and labels in sync with THEME_REGISTRY
#
# This consolidated workflow handles syncing:
# - Issue templates: bug_report.yml theme dropdown
# - Theme READMEs: master listing and per-theme documentation
# - Repository labels: Creates theme/* labels so auto-labelling works
#
# How it works:
# 1. Monitors THEME_REGISTRY (registry-core.ts) for changes on main branch
# 2. Syncs repository labels (creates missing theme/* labels)
# 3. Checks what files need syncing (issue templates, READMEs)
# 4. Runs sync operations only for out-of-sync files
# 5. Commits all changes in a single atomic commit
#
# Manual sync:
#   npm run sync:issue-templates
#   npm run sync:theme-readmes
#
# Previously split across sync-issue-templates.yml and sync-theme-readmes.yml
name: Sync Theme Metadata

on:
  push:
    branches: ["main"]
    paths:
      - 'src/themes/registry/registry-core.ts'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (check only, no changes) - set to false to make actual changes'
        required: false
        default: true
        type: boolean

permissions:
  contents: write
  issues: write  # Required to create/update repository labels

# Prevent multiple sync operations from running simultaneously
# to avoid race conditions on commits
concurrency:
  group: sync-theme-metadata
  cancel-in-progress: false

jobs:
  sync-metadata:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Setup Node
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
        with:
          node-version-file: '.node-version'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      # Extract theme data using theme CLI
      # This uses tsx to run TypeScript and outputs JSON
      - name: Get theme data
        id: get-themes
        run: |
          themes=$(npm run theme list:labels --silent)
          echo "themes=$themes" >> $GITHUB_OUTPUT
          echo "ðŸ“‹ Extracted theme data: $themes"

      # Sync repository labels for themes
      # Creates theme/* labels if they don't exist, ensuring auto-labelling works
      # Also detects orphaned labels from renamed/deleted themes
      - name: Sync theme labels
        id: sync-labels
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          THEME_DATA: ${{ steps.get-themes.outputs.themes }}
        with:
          script: |
            const isDryRun = context.eventName === 'workflow_dispatch' && ${{ inputs.dry_run || false }};

            // Theme data comes from previous step via env variable
            const themeDataJson = process.env.THEME_DATA;
            let themes = [];
            try {
              themes = JSON.parse(themeDataJson);
              console.log(`ðŸ“‹ Found ${themes.length} themes in registry`);
            } catch (error) {
              console.error('âŒ Failed to parse theme data:', error.message);
              core.setFailed('Failed to parse theme data');
              return;
            }

            // Get existing labels
            const { data: existingLabels } = await github.rest.issues.listLabelsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            const existingLabelNames = new Set(existingLabels.map(l => l.name));

            // Build set of expected theme labels
            const expectedThemeLabels = new Set(themes.map(t => `theme/${t.id}`));

            // Theme label color (GitHub green)
            const THEME_LABEL_COLOR = '0e8a16';

            // Track changes for summary
            const labelsToCreate = [];
            const labelsToDelete = [];

            // Find labels to create
            for (const theme of themes) {
              const labelName = `theme/${theme.id}`;
              if (!existingLabelNames.has(labelName)) {
                labelsToCreate.push({ name: labelName, theme: theme.name });
              }
            }

            // Find orphaned theme/* labels (exist but not in registry)
            for (const label of existingLabels) {
              if (label.name.startsWith('theme/') && !expectedThemeLabels.has(label.name)) {
                labelsToDelete.push(label.name);
              }
            }

            // Base labels that should always exist
            const baseLabels = [
              { name: 'theme', color: '0e8a16', description: 'Issues related to themes' },
              { name: 'existing-theme', color: '0e8a16', description: 'Bug reports for existing themes' },
              { name: 'new-theme', color: '1d76db', description: 'Suggestions for new themes' }
            ];

            const baseLabelsToCreate = baseLabels.filter(l => !existingLabelNames.has(l.name));

            // Output summary
            console.log('\nðŸ“Š Label Sync Summary:');
            console.log(`   Labels to create: ${labelsToCreate.length + baseLabelsToCreate.length}`);
            console.log(`   Orphaned labels to delete: ${labelsToDelete.length}`);

            if (labelsToCreate.length > 0) {
              console.log('\n   ðŸ†• New theme labels:');
              labelsToCreate.forEach(l => console.log(`      - ${l.name} (${l.theme})`));
            }

            if (baseLabelsToCreate.length > 0) {
              console.log('\n   ðŸ†• New base labels:');
              baseLabelsToCreate.forEach(l => console.log(`      - ${l.name}`));
            }

            if (labelsToDelete.length > 0) {
              console.log('\n   ðŸ—‘ï¸ Orphaned labels (theme renamed/deleted):');
              labelsToDelete.forEach(l => console.log(`      - ${l}`));
            }

            // Set outputs for summary
            core.setOutput('labels_to_create', labelsToCreate.length + baseLabelsToCreate.length);
            core.setOutput('labels_to_delete', labelsToDelete.length);
            core.setOutput('labels_created', JSON.stringify(labelsToCreate.map(l => l.name)));
            core.setOutput('labels_deleted', JSON.stringify(labelsToDelete));

            if (isDryRun) {
              console.log('\nðŸ” DRY RUN - no changes made');
              return;
            }

            // Actually create labels
            for (const theme of themes) {
              const labelName = `theme/${theme.id}`;
              
              if (existingLabelNames.has(labelName)) {
                console.log(`âœ“ Label exists: ${labelName}`);
                continue;
              }

              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: labelName,
                  color: THEME_LABEL_COLOR,
                  description: `Issues related to the ${theme.name} theme`
                });
                console.log(`âœ… Created label: ${labelName}`);
              } catch (error) {
                console.error(`âŒ Failed to create label ${labelName}:`, error.message);
              }
            }

            // Create base labels
            for (const label of baseLabels) {
              if (existingLabelNames.has(label.name)) {
                console.log(`âœ“ Label exists: ${label.name}`);
                continue;
              }

              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name,
                  color: label.color,
                  description: label.description
                });
                console.log(`âœ… Created label: ${label.name}`);
              } catch (error) {
                console.error(`âŒ Failed to create label ${label.name}:`, error.message);
              }
            }

            // Delete orphaned labels
            for (const labelName of labelsToDelete) {
              try {
                await github.rest.issues.deleteLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: labelName
                });
                console.log(`ðŸ—‘ï¸ Deleted orphaned label: ${labelName}`);
              } catch (error) {
                console.error(`âŒ Failed to delete label ${labelName}:`, error.message);
              }
            }

      # Check sync status for all metadata files
      - name: Check issue templates sync status
        id: check-templates
        run: |
          if npm run theme sync:templates -- --check; then
            echo "needs_sync=false" >> $GITHUB_OUTPUT
            echo "âœ… Issue templates are in sync"
          else
            echo "needs_sync=true" >> $GITHUB_OUTPUT
            echo "âš ï¸ Issue templates need syncing"
          fi
        continue-on-error: true

      - name: Check theme READMEs sync status
        id: check-readmes
        run: |
          if npm run theme sync:readmes -- --check; then
            echo "needs_sync=false" >> $GITHUB_OUTPUT
            echo "âœ… Theme READMEs are in sync"
          else
            echo "needs_sync=true" >> $GITHUB_OUTPUT
            echo "âš ï¸ Theme READMEs need syncing"
          fi
        continue-on-error: true

      # Sync issue templates if needed
      - name: Sync issue templates
        if: steps.check-templates.outputs.needs_sync == 'true' && (github.event_name == 'push' || inputs.dry_run == false)
        run: npm run theme sync:templates

      # Sync theme READMEs if needed
      - name: Sync theme READMEs
        if: steps.check-readmes.outputs.needs_sync == 'true' && (github.event_name == 'push' || inputs.dry_run == false)
        run: npm run theme sync:readmes

      # Single atomic commit for all changes
      # Uses [skip ci] to prevent triggering workflows again
      - name: Commit changes
        if: (steps.check-templates.outputs.needs_sync == 'true' || steps.check-readmes.outputs.needs_sync == 'true') && (github.event_name == 'push' || inputs.dry_run == false)
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Stage all potential changed files
          git add .github/ISSUE_TEMPLATE/bug_report.yml
          git add src/themes/README.md
          git add src/themes/*/README.md
          
          # Build commit message based on what changed
          CHANGES=""
          if [ "${{ steps.check-templates.outputs.needs_sync }}" == "true" ]; then
            CHANGES="${CHANGES}issue templates"
          fi
          if [ "${{ steps.check-readmes.outputs.needs_sync }}" == "true" ]; then
            if [ -n "$CHANGES" ]; then
              CHANGES="${CHANGES}, "
            fi
            CHANGES="${CHANGES}theme READMEs"
          fi
          
          git commit -m "chore: sync ${CHANGES} [skip ci]" || exit 0
          git push

      # Report dry run results (only for manual workflow_dispatch with dry_run=true)
      - name: Dry run summary
        if: github.event_name == 'workflow_dispatch' && inputs.dry_run == true
        run: |
          echo "ðŸ” DRY RUN MODE - No changes were made"
          echo ""
          echo "================================"
          echo "ðŸ“Š WHAT WOULD CHANGE:"
          echo "================================"
          echo ""
          echo "ðŸ·ï¸ Labels:"
          echo "   - Would create: ${{ steps.sync-labels.outputs.labels_to_create || 0 }} labels"
          echo "   - Would delete: ${{ steps.sync-labels.outputs.labels_to_delete || 0 }} orphaned labels"
          echo ""
          echo "ðŸ“„ Issue Templates:"
          if [ "${{ steps.check-templates.outputs.needs_sync }}" == "true" ]; then
            echo "   - âš ï¸ NEEDS UPDATE - Theme dropdown out of sync"
            echo "   - Run without dry_run to update .github/ISSUE_TEMPLATE/bug_report.yml"
          else
            echo "   - âœ… Already in sync"
          fi
          echo ""
          echo "ðŸ“– Theme READMEs:"
          if [ "${{ steps.check-readmes.outputs.needs_sync }}" == "true" ]; then
            echo "   - âš ï¸ NEEDS UPDATE - READMEs out of sync"
            echo "   - Files that would change:"
            echo "     - src/themes/README.md (master listing)"
            echo "     - src/themes/*/README.md (per-theme docs)"
          else
            echo "   - âœ… Already in sync"
          fi
          echo ""
          echo "================================"
          echo "To apply changes, run workflow with dry_run = false"
          echo "================================"

      # Generate job summary
      - name: Generate summary
        if: always()
        run: |
          IS_DRY_RUN="${{ github.event_name == 'workflow_dispatch' && inputs.dry_run == true }}"
          LABELS_CREATE="${{ steps.sync-labels.outputs.labels_to_create || 0 }}"
          LABELS_DELETE="${{ steps.sync-labels.outputs.labels_to_delete || 0 }}"
          LABELS_CREATED_JSON='${{ steps.sync-labels.outputs.labels_created || '[]' }}'
          LABELS_DELETED_JSON='${{ steps.sync-labels.outputs.labels_deleted || '[]' }}'
          
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## ðŸ”„ Theme Metadata Sync
          
          EOF
          
          if [ "$IS_DRY_RUN" == "true" ]; then
            echo "> ðŸ” **DRY RUN MODE** - No changes were made. Set \`dry_run: false\` to apply changes." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ### ðŸ·ï¸ Repository Labels
          
          | Action | Count |
          |--------|-------|
          | Labels to create | ${LABELS_CREATE} |
          | Orphaned labels to delete | ${LABELS_DELETE} |
          
          EOF
          
          # Show created labels if any
          if [ "$LABELS_CREATE" != "0" ]; then
            echo "<details><summary>Labels to create</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "$LABELS_CREATED_JSON" | jq -r '.[]' >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "(none)"
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Show deleted labels if any
          if [ "$LABELS_DELETE" != "0" ]; then
            echo "<details><summary>Orphaned labels to delete</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "$LABELS_DELETED_JSON" | jq -r '.[]' >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "(none)"
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ### ðŸ“„ File Sync Status
          
          | File | Status |
          |------|--------|
          | Issue Templates | ${{ steps.check-templates.outputs.needs_sync == 'true' && (github.event_name == 'workflow_dispatch' && inputs.dry_run == true && 'ðŸ” Would update' || 'ðŸ”„ Updated') || 'âœ… In sync' }} |
          | Theme READMEs | ${{ steps.check-readmes.outputs.needs_sync == 'true' && (github.event_name == 'workflow_dispatch' && inputs.dry_run == true && 'ðŸ” Would update' || 'ðŸ”„ Updated') || 'âœ… In sync' }} |
          
          ---
          
          **Note on theme renames/deletions:**
          - âœ… Labels are automatically cleaned up (orphaned \`theme/*\` labels deleted)
          - âœ… Issue templates are regenerated (old themes removed from dropdown)
          - âš ï¸ Old theme folders in \`src/themes/\` must be manually deleted
          EOF
